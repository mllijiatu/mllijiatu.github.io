---
layout:     post
title:      Java混合编程
subtitle:   李嘉图的博客
date:       2020-05-03
author:     李嘉图
header-img: img-post/java5.png
catalog: false
tags:
- Java
---
# RMI
单虚拟机JVM上的程序运行
- 启动一个main程序，然后重复以下的2个步骤
- new 出一个对象
- 调用对象的某一个方法

多虚拟机JVM的程序运行
- 启动多个main程序，这些程序可以部署在多个机器/虚拟机上
- 多个进程可通过网络互相传递消息进行协作
- *进程通过RMI可调用另一个机器的Java的函数*
![zwt]({{site.baseurl}}/img-post/java5.png)

![zwt]({{site.baseurl}}/img-post/java6.png)

---
**RMI的参数和返回值**

(自动化)传递远程对象(实现Remote接口)
- 当一个对远程对象的引用从一个JVM传递到另一个JVM
- 该远程对象的发送者和接收者将持有同一个实体对象的引用。
- 这个引用并非是一个内存位置，而是由网络地址和该远程对象的唯一标识符构成的。
- *两个JVM拥有同一个对象*

(自动化)传递可序列化对象(实现Serializable接口)
- JVM中的一个对象经过序列化后的字节，通过网络，其副本传递到另
一个JVM中，并重新还原为一个Java对象。
- *每个JVM拥有自己的对象*

---
RMI优点
- 跨平台分布式对象调用
- 完全对象支持
- 安全策略

RMI缺点
- 双方必须是Java语言实现
- 不如消息传递协作方便

---
# JNI
- Java和C互操作
- JNI，Java Native Interface
- Java和本地C代码进行互操作
- Java调用C程序完成一些需要快速计算的功能(常见，重点)
- C调用Java程序(基于反射的方法)
![zwt]({{site.baseurl}}/img-post/java7.png)
![zwt]({{site.baseurl}}/img-post/java8.png)
在Java类中声明一个本地方法
- 调用javac.exe编译，得到HelloNative.class
- 调用javah.exe得到包含该方法(Java_HelloNative_greeting)的头文件
HelloNative.h
- 实现.c文件(对应HelloNative.h)
- 将.c和.h文件，整合为共享库(DLL)文件
- 在Java类中，加载相应的共享库文件
